/*
Memoization은 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 
다시 계사하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술이다. 

DP의 핵심 기술이 되기도 하는데 이 계획법은 그리디 알고리즘과 같이 최적화 문제를 해결하는 AL이다.
좀 더 자세히 설명하자면, 먼저 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 
보다 큰 크기의 부분 문제들을 해결함으로써, 최종적으로 원래 두어진 입려의 문제를 해결하는 AL이라고 표현 할 수 있다.

DP은 Optimal Substructure인 경우와 Overlapping Recursive Calls인 경우 사용하는데 ,
optimal Substructure은 큰 문제의 최적 솔루션에 작은 문제의 최적 솔루션이 포함되는 경우
Overlapping Recursive Calls는재귀적 해법으로 풀면 같은 문제에 대한 재귀호출이 심각하게 중복되는 겨웅 
두 요건이 충족되는 경우 동적 계획법이 좋은 해결법으로 사용되고 있다. 

동적 계획법 기반의 알고리즘 전략은 문제를 부분 문제로 나누고, 가장 작은 부분붑터 해를 구하여 테이블에 저장하며,
이 테이블의 값을 사용하여 좀더 큰 부분의 해를 구하고, 이를 반복하여 마지막 해를 구하는데 이를 Bottom-Up(상향식 방법)
이라 부르기도 한다. 

이러한 방법이 재귀적 호출보다 뛰어난 이유는 재귀적 호출 자체가 내부 시스템 호출 Stack을 사요하는 오버헤드가
발생하는데, 반대로 동적 계획법을 사용한 경우 이러한 오버헤드가 발생하지 않기 때문이다. 
*/
#include<stdio.h> 
#define MAXSIZE 1000
int A[MAXSIZE]; 
int f(int n) 
{
	A[0] = 0; 
	A[1] = 1;
	for (int i =2; i <= n; i++) {
		A[i] = A[i - 1] + A[i -2] ; 
	}
	return A[n];
}
/*
for문을 돌면서 i번째 원소에 값을 대입한다. 
눅히 위의 코드는 Memoiazation의 특성을 활용, DP을 사용하여 해결한 소스 코드 이므로, 피보나치 열을 
시간복잡도 O(n)에 수행한다. 
*/
int main() {
	int n; 
	scanf("%d" , &n);
	printf("%d\n", f(n));
	return 0;
}
