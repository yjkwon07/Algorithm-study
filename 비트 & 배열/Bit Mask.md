<h1> 비트 마스크 (Bit Mask)기법</h1>

  - 메모리를 적게 사용할 수 있다.
  - 프로그램이 더욱 빠르게 동작
  - 소스코드가 직관적으로 변경 
  
<h2> 2진수 형태로 출력 </h2>
int (32비트) 기준, 가장 왼쪽 비트 부터 오른쪽 비트까지 하나 씩 순회하면서 각 원소를 가지고 있는지 & 연산으로 1 혹은 0을 출력.
  
<h2> 모든 원소를 삭제하기 </h2>
모든 원소를 삭제하고자 할 때는 단순히 변수를 0으로 초기화 하면 된다. <br>
기본적으로 컴퓨터는 2의 보수 체계를 가지고 있기 때문에 0으로 초기화 하면 모든 비트가 0이 된다. 
  
<h2> 모든 원소를 포함시키기 </h2>
모든 원소를 포함시키고자 할 때는 변수에 -1을 넣으면 된다. <br>
컴퓨터는 2의 보수 체계를 가지고 있기 때문에 -1로 초기화하면 모든 비트가 1이 된다.

<h2> 특정 원소 삭제하기 </h2>
특정 원소를 삭제할 때는 (1 << i)에 NOT(~) 연산을 적용하여 변수 a와 AND(&)연산을 수행하면 된다. <br>
~(1 << i)는 특정 위치의 비트만 0이고 나머지는 전부 1이기 때문이다.
  
<h2> 특정 원소 포함시키기 </h2>
특정 원소를 포함시킬 때는 (1 << i)를 변수 a와 OR(|)연산을 수행하면 된다. <br>
왜냐하면 (1 << i)를 했을 때 특정한 비트가 1이 될 것이며 이를 OR 연산하면 항상 1이라는 결과가 반환되기 때문이다.
  
<h2> 특정 원소 포함 여부 확인하기 </h2>
특정 원소의 포함 여부를 확인할 때는 (1 << i)을 하여 특정 비트가 1이 되도록 하고 이를 a와 AND(&)연산을 수행하면 된다.<br>
특정 비트가 1일 때에만 1이 반환되기 때문에 포함 여부를 확인 가능
  
<h2> 특정 원소를 토글하기 </h2>
특정 원소를 토글하고자 할 때는 (1 << i)를 하여 특정 비트가 1이 되도록 하고 이를 a와 XOR(^)연산을 수행<br>
결과적으로 특정 비트가 1이면 0, 0이면 1로 바뀐다.
  
<h2> 마지막 원소 구하기 </h2>
컴퓨터는 내부적으로 2의 보수 체계를 사용하므로 -a는 a에 대한 1의 보수에서 1을 더한 값과 동일<br>
그러므로 a와 -a를 AND(&)연산하면 가장 작은 비트인 마지막 원소를 구할 수 있다.<br>
이 때 마지막 원소는 정수형으로 반환되어 오른쪽에서 3번째 원소라면 2^(3-1) = 4<br>
<h2><a href="https://github.com/yjkwon07/Algorithm-study/blob/master/%EB%B9%84%ED%8A%B8%20%26%20%EB%B0%B0%EC%97%B4/bit%20mask.cpp"> Code </a></h2>

