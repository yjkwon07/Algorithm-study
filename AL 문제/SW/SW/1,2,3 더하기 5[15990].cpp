#include<iostream>
#include<cstdio>
/*
	1, 2, 3 더하기 5 
	https://www.acmicpc.net/problem/15990
	
	정수 n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 문제
	단, 같은 수를 두 번 이상 연속해서 사용하면 안된다.
	D[i][j] = i를 1, 2, 3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 j 
	D[i][j] = i를 1, 2, 3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 1
		바로 전에 사용할 수 있는 수는 2, 3
		D[i][1] = D[i-1][2] + D[i-1][3]
	D[i][j] = i를 1, 2, 3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 2
		바로 전에 사용할 수 있는 수는 1, 3
		D[i][2] = D[i-2][1] + D[i-2][3]
	D[i][j] = i를 1, 2, 3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 3
		바로 전에 사용할 수 있는 수는 2, 3
		D[i][3] = D[i-3][2] + D[i-3][3]
	
	1, 2, 3 더하기에서 한 것 처럼 D[0] = 1로 초기화하면 중복이 발생한다.
	D[0][1] = 1, D[0][2] = 1, D[0][3] =1로 초기화를 했다면
	D[1][1] = D[0][2] + D[0][3] = 2 (중복이 발생하게 된다)
	
	따라서, 이 문제는 예외 처리를 해야 한다.
	D[i][1]
		D[i-1][2] + D[i-1][3] ( i >1)
		1 (i == 1)
		0 (i < 1)
	D[i][2]
		D[i-2][1] + D[i-2][3] ( i >2)
		1 (i == 2)
		0 (i < 2)
	D[i][3]
		D[i-3][1] + D[i-3][2] ( i >3)
		1 (i == 3)
		0 (i < 3)
*/
long long d[1000001][4];
const long long mod = 1000000009LL;
const int limit = 100000;
int main() {
	for (int i = 1; i <= limit; i++) {
		if (i - 1 >= 0) {
			d[i][1] = d[i - 1][2] + d[i - 1][3];
			if (i == 1) {
				d[i][1] = 1;
			}
		}
		if (i - 2 >= 0) {
			d[i][2] = d[i - 2][1] + d[i - 2][3];
			if (i == 2) {
				d[i][2] = 1;
			}
		}
		if (i - 3 >= 0) {
			d[i][3] = d[i - 3][1] + d[i - 3][2];
			if (i == 3) {
				d[i][3] = 1;
			}
		}
		d[i][1] %= mod;
		d[i][2] %= mod;
		d[i][3] %= mod;
	}
	int t;
	scanf("%d", &t);
	while (t--) {
		int n;
		scanf("%d", &n);
		printf("%lld\n", (d[n][1] + d[n][2] + d[n][3]) % mod);
	}
}