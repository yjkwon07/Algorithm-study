/*
	포도주 시식 
	https://www.acmicpc.net/problem/2156

	포도주가 일렬로 놓여져 있고, 다음과 같은 2가지 규칙을 지키면서 포도주를 최대한 많이 마시려고 한다.
	포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.
	연속으로 놓여 있는 3잔을 모두 마실 수는 없다
	D[i] = A[1] --- A[i]까지 포도주를 마셨을 때, 마실 수 있는 포도주의 최대 양

	i에게 가능한 경우
	i번째 포도주를 마시는 경우
		D[i -1] + A[i]
	i번째 포도주를 마시지 않는 경우
		D[i -1]
	D[i] = max(D[i-1] + A[i], D[i-1])
	위의 식은 포도주를 연속해서 3잔 마시면 안되는 경우를 처리하지 못한다.
	
	D[i][0] = 0번 연속해서 마신 포도주 -> A[i]를 마시지 않음
		max(D[i-1][0], D[i-1][1], D[i-1][2])
	D[i][1] = 1번 연속해서 마신 포도주 -> A[i-1]을 마시지 않았음
		D[i-1][0] + A[i]
	D[i][2] = 2번 연속해서 마신 포도주 -> A[i-1]을 마시고, A[i-2]는 마시지 않았어야 함
		D[i-1][1] +A[i]

	D[i][0] = 0번 연속해서 마신 포도주 -> A[i]를 마시지 않음
		D[i-1]
	D[i][1] = 1번 연속해서 마신 포도주 -> A[i-1]을 마시지 않았음
		D[i-2] + A[i]
	D[i][2] = 2번 연속해서 마신 포도주 -> A[i-1]을 마시고, A[i-2]는 마시지 않았어야 함
		D[i-3]+ A[i-1] +A[i]
	D[i] = max(D[i-1], D[i-2]+A[i], D[i-3]+ A[i-1]+A[i])
		i-2, i-3 때문에 예외 처리가 예상되기 때문에 
		D[1] = A[1]
		D[2] = A[1] + A[2]
		로 미리 처리를 해두고
		i = 3부터 문제를 푸는 것이 좋다.
*/
#include<iostream>
#include<algorithm>
using namespace std;
int a[10001];
int d[10001][2];
int main() {
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}

	for (int i = 1; i <= n; i++) {
		d[i][0] = max(d[i - 1][0], max(d[i - 1][1], d[i - 1][2]));
		d[i][1] = d[i - 1][0] + a[i];
		d[i][2] = d[i - 1][1] + a[i];
	}
	int ans = 0;
	for (int i = 1; i <= n; i++)
		ans = max(d[i][0], max(d[i][1], d[i][2]));
	cout << ans;
	return 0;
}
